export const vitePluginGraphqlLoaderUniqueChecker = (defs) => {
    const names = {};
    return defs.filter(function (def) {
        if (def.kind !== "FragmentDefinition")
            return true;
        const name = def.name.value;
        if (names[name]) {
            return false;
        }
        else {
            names[name] = true;
            return true;
        }
    });
};
export const vitePluginGraphqlLoaderExtractQuery = (doc, operationName) => {
    const collectFragmentReferences = (node, refs) => {
        if (node.kind === "FragmentSpread") {
            refs.add(node.name.value);
        }
        else if (node.kind === "VariableDefinition") {
            const type = node.type;
            if (type.kind === "NamedType") {
                refs.add(type.name.value);
            }
        }
        if (node && "selectionSet" in node && node.selectionSet) {
            node.selectionSet.selections.forEach((selection) => {
                collectFragmentReferences(selection, refs);
            });
        }
        if (node && "variableDefinitions" in node && node.variableDefinitions) {
            node.variableDefinitions.forEach((def) => {
                collectFragmentReferences(def, refs);
            });
        }
        if (node && "definitions" in node && node.definitions) {
            node.definitions.forEach((def) => {
                collectFragmentReferences(def, refs);
            });
        }
        return refs;
    };
    const extractReferences = (doc) => {
        const definitionRefs = {};
        doc.definitions.forEach(function (def) {
            if ("name" in def && def.name) {
                definitionRefs[def.name.value] = collectFragmentReferences(def, new Set());
            }
        });
        return definitionRefs;
    };
    const findOperation = (doc, name) => {
        for (let i = 0; i < doc.definitions.length; i++) {
            const element = doc.definitions[i];
            if (element &&
                "name" in element &&
                element.name &&
                element.name.value == name) {
                return element;
            }
        }
    };
    const definitionRefs = extractReferences(doc);
    const newDoc = Object.assign({}, doc, {
        definitions: [findOperation(doc, operationName)],
    });
    const opRefs = definitionRefs[operationName] || new Set();
    const allRefs = new Set();
    let newRefs = new Set();
    opRefs.forEach((refName) => {
        newRefs.add(refName);
    });
    while (newRefs.size > 0) {
        const prevRefs = newRefs;
        newRefs = new Set();
        prevRefs.forEach((refName) => {
            if (!allRefs.has(refName)) {
                allRefs.add(refName);
                const childRefs = definitionRefs[refName] || new Set();
                childRefs.forEach((childRef) => {
                    newRefs.add(childRef);
                });
            }
        });
    }
    allRefs.forEach((refName) => {
        const op = findOperation(doc, refName);
        if (op) {
            newDoc.definitions.push(op);
        }
    });
    return newDoc;
};
//# sourceMappingURL=snippets.js.map